extern crate permutohedron;

use std::collections::VecDeque;
use crate::permutohedron::LexicalPermutation;
use std::iter::FromIterator;

mod intcode;


struct Amplifier {
    ip: usize,
    mem: Vec<isize>,
    input: VecDeque<isize>
}


/// Run Amplifier program until some output generated; None is returned in case
/// the program halts without producing any output.
fn run(amp: &mut Amplifier) -> Option<isize> {
    let mut output = None;
    let input = &mut amp.input;
    loop {
        let opcode = intcode::step(
            &mut amp.mem,
            &mut amp.ip,
            |val| output = Some(val),
            || input.pop_front().expect("Missing input")
            );

        if opcode == 4 || opcode == 99 {
            break;
        }
    }
    output
}


/// Run a sequence of Amplifiers, feeding the output of one as input to the next.
/// Returns the output of the final Amplifier, or None if any of the
/// Amplifiers halts without producing output.
fn sequence(amplifiers: &mut [Amplifier], first_input: isize) -> Option<isize> {
    let mut input = first_input;
    for mut amp in amplifiers {
        amp.input.push_back(input);
        match run(&mut amp) {
            Some(output) => input = output,
            None         => return None
        };
    }
    Some(input)
}


fn setup_amplifier_chain(program: &[isize], phase_signals: &[isize]) -> Vec<Amplifier> {
    phase_signals.iter().map(|phase_signal| {
        Amplifier {
            ip: 0,
            mem: program.to_vec(),
            input: VecDeque::from_iter(vec![*phase_signal]),
        }
    }).collect()
}

/// Finds the maximum thrust generated by running the given program on a sequence of chained
/// amplifiers; the number of amplifiers is defined by the number of phase signals given. The
/// function will iterate all permutations of phase signals and find the maximum output. The actual
/// sequencing of amplifiers is defined by the 'go' argument.
fn find_maximum_thrust_by(program: &[isize], phase_signals: &[isize], go: impl Fn(&mut [Amplifier]) -> isize) -> isize {
    let mut max_thrust = 0;
    let mut phase_permutation = phase_signals.to_vec();

    loop {
        let mut amplifiers = setup_amplifier_chain(program, &phase_permutation);
        max_thrust = std::cmp::max(max_thrust, go(&mut amplifiers));
        if !phase_permutation.next_permutation() {
            return max_thrust;
        }
    }
}


fn part_one(program: &[isize]) -> isize {
    let phase_signals: Vec<_> = (0..5).collect();
    find_maximum_thrust_by(program, &phase_signals, |mut amplifiers| {
        sequence(&mut amplifiers, 0).unwrap_or(0)
    })
}


fn part_two(program: &[isize]) -> isize {
    let phase_signals: Vec<_> = (5..10).collect();
    find_maximum_thrust_by(program, &phase_signals, |mut amplifiers| {
        let mut input = 0;
        loop {
            match sequence(&mut amplifiers, input) {
                Some(thrust) => input = thrust,
                None         => return input
            };
        }
    })
}


fn main() {
    let input = std::fs::read_to_string("input.txt")
        .expect("Failed to read input.txt");

    let program = intcode::parse(&input)
        .expect("Failed to parse input file");

    println!("Part one: {:?}", part_one(&program));
    println!("Part two: {:?}", part_two(&program));
}
